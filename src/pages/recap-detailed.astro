---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Detailed News Landscape Recap">
  <main class="container mx-auto px-4 py-8 max-w-6xl">
    <!-- Hero Section -->
    <div id="hero-section" class="text-center mb-12 min-h-screen flex flex-col justify-center">
      <h1 class="text-4xl font-bold mb-4">
        <span
          class="bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent"
        >
          TODAY THE WORLD IS OBSESSED BY
        </span>
        <br />
        <span
          id="top-entity"
          class="text-6xl font-black bg-gradient-to-r from-red-500 via-orange-500 to-yellow-500 bg-clip-text text-transparent drop-shadow-lg"
        >
        </span>
      </h1>
      <!-- World map showing how much each country talks about the top NER -->
      <div id="world-map-recap" class="mt-8"></div>
    </div>

    <!-- Temporal Trends Section -->
    <div id="temporal-section" class="mt-16 text-center min-h-screen flex flex-col justify-center">
      <h1 id="temporal-question" class="text-3xl font-bold mb-8">
        Has <span class="top-entity-ref text-purple-600">...</span> always
        been so hot?
      </h1>
      <!-- Topic trend graph for the top NER -->
      <div class="grid grid-cols-1 lg:grid-cols-7 gap-8 h-[400px]">
        <div class="border rounded-xl bg-card shadow-lg p-6 lg:col-span-4">
          <h3 class="text-lg font-semibold mb-4 text-left">
            Top 5 Topics of today
          </h3>
          <div id="temporal-table-recap" class="h-full"></div>
        </div>
        <div
          class="border rounded-xl bg-card shadow-lg p-6 flex flex-col lg:col-span-3"
        >
          <h3 class="text-lg font-semibold mb-4 text-left">
            7-Day Trend Evolution
          </h3>
          <div id="temporal-chart-recap" class="flex-1 min-h-0"></div>
        </div>
      </div>
    </div>

    <!-- Network Section -->
    <div id="network-section" class="mt-16 text-center min-h-screen flex flex-col justify-center">
      <h1 id="network-title" class="text-3xl font-bold mb-4">
        <span class="top-entity-ref text-green-600">...</span> POWER WEB
      </h1>
      <p class="text-muted-foreground mb-8">
        Click and drag to explore • Mouse wheel to zoom • Click nodes for
        details
      </p>
      <!-- Network graph filtered to only show nodes connected to the top NER -->
      <div
        id="network-recap"
        class="w-full h-[600px] border rounded-xl bg-card shadow-lg"
      >
      </div>
    </div>

    <!-- Insights Section -->
    <div
      id="insights-section"
      class="mt-16 text-center bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-950/10 dark:to-purple-950/10 rounded-xl border p-8 min-h-screen flex flex-col justify-center"
    >
      <h2 class="text-2xl font-bold mb-4">Key Insights</h2>
      <div id="insights-content" class="text-muted-foreground">
        <p>Loading insights about <span class="top-entity-ref">...</span>...</p>
      </div>
    </div>
  </main>
</Layout>

<script>
  import React from "react";
  import ReactDOM from "react-dom/client";
  import WorldMapNER from "../components/world-map/WorldMapNER";
  import TopicTable from "../components/TopicTable";
  import TopicTrendChart from "../components/TopicTrendChart";
  import EntityPowerNetwork from "../components/EntityPowerNetwork";
  import { ScrollAnimationController, animationStyles } from "../lib/animations";

  // Inject animation styles
  const styleSheet = document.createElement('style');
  styleSheet.textContent = animationStyles;
  document.head.appendChild(styleSheet);

  // Initialize animation controller
  let animationController: ScrollAnimationController;

  // Function to update all entity references
  function updateEntityReferences(entity: string) {
    const refs = document.querySelectorAll('.top-entity-ref');
    refs.forEach((ref) => {
      ref.textContent = entity.toUpperCase();
    });
  }

  // Function to create a custom world map that shows coverage of the top entity
  function createCustomWorldMap(topEntity: string) {
    const worldMapElement = document.getElementById("world-map-recap");
    if (worldMapElement && topEntity) {
      // For now, we'll use the existing WorldMapPage but we could enhance it
      // to show entity-specific data in the future
      const root = ReactDOM.createRoot(worldMapElement);
      root.render(React.createElement(WorldMapNER, { entity: topEntity }));
    }
  }

  // Function to create filtered network showing only connections to the top entity
  function createFilteredNetwork(topEntity: string) {
    const networkElement = document.getElementById("network-recap");
    if (networkElement && topEntity) {
      const root = ReactDOM.createRoot(networkElement);

      // Get today's date in DD.MM.YYYY format
      const today = new Date();
      const day = today.getDate().toString().padStart(2, "0");
      const month = (today.getMonth() + 1).toString().padStart(2, "0");
      const year = today.getFullYear();
      const formattedDate = `${day}.${month}.${year}`;

      root.render(
        React.createElement(EntityPowerNetwork, {
          targetEntity: topEntity,
          date: formattedDate,
          className: "w-full h-full",
        }),
      );
    }
  }

  // Function to load temporal trends data and create components
  async function createTemporalTrends(topEntity: string) {
    const tableElement = document.getElementById("temporal-table-recap");
    const chartElement = document.getElementById("temporal-chart-recap");

    if (!tableElement || !chartElement) return;

    try {
      // Helper functions
      function formatDate(date: Date): string {
        const day = date.getDate().toString().padStart(2, "0");
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const year = date.getFullYear();
        return `${day}.${month}.${year}`;
      }

      function getLastNDays(n: number): string[] {
        const dates: string[] = [];
        const today = new Date();

        for (let i = n - 1; i >= 0; i--) {
          const date = new Date(today);
          date.setDate(today.getDate() - i);
          dates.push(formatDate(date));
        }

        return dates;
      }

      async function loadTopicsForDate(date: string): Promise<any> {
        try {
          const response = await fetch(`/data/${date}/topics.json`);
          if (!response.ok) return null;
          return await response.json();
        } catch (error) {
          console.warn(`Error loading data for ${date}:`, error);
          return null;
        }
      }

      // Get the last 7 days
      const last7Days = getLastNDays(7);
      const today = last7Days[last7Days.length - 1];
      const yesterday = last7Days[last7Days.length - 2];

      // Load data for all days
      const dailyDataPromises = last7Days.map(async (date) => ({
        date,
        data: await loadTopicsForDate(date),
      }));

      const dailyDataResults = await Promise.all(dailyDataPromises);

      // Filter out failed loads and create data map
      const dailyData: any = {};
      const availableDates: string[] = [];

      dailyDataResults.forEach(({ date, data }) => {
        if (data) {
          dailyData[date] = data;
          availableDates.push(date);
        }
      });

      if (availableDates.length === 0) {
        console.warn("No temporal data available");
        return;
      }

      // Get today's and yesterday's data
      const todayData = dailyData[today];
      const yesterdayData = dailyData[yesterday] || null;

      if (!todayData) {
        console.warn("Today's data not available");
        return;
      }

      // Process table data for top 5 topics only
      const processTableData = (todayData: any, yesterdayData: any) => {
        let yesterdayRankings: any = {};
        if (yesterdayData) {
          const yesterdayEntries = Object.entries(yesterdayData)
            .filter(([_, score]) => typeof score === "number" && score > 0)
            .sort(([, a], [, b]) => Number(b) - Number(a));

          yesterdayEntries.forEach(([topic, _], index) => {
            yesterdayRankings[topic] = index + 1;
          });
        }

        const tableData = Object.entries(todayData)
          .map(([topic, todayScore]) => {
            const yesterdayScore =
              yesterdayData && yesterdayData[topic] ? yesterdayData[topic] : 0;

            let isTrendingUp = null;
            let isPresenceTrendingUp = null;
            let percentageChange = null;

            if (yesterdayScore === 0) {
              percentageChange =
                Number(todayScore) > 0 ? Number(todayScore) : 0;
              isPresenceTrendingUp = Number(todayScore) > 0 ? true : null;
            } else {
              percentageChange = parseFloat(
                (Number(todayScore) - Number(yesterdayScore)).toFixed(1),
              );
              isPresenceTrendingUp =
                Number(todayScore) > Number(yesterdayScore)
                  ? true
                  : Number(todayScore) < Number(yesterdayScore)
                    ? false
                    : null;
            }

            return {
              topic,
              latestScore: Number(todayScore),
              isTrendingUp,
              isPresenceTrendingUp,
              percentageChange,
            };
          })
          .filter((item) => item.latestScore > 0)
          .sort((a, b) => b.latestScore - a.latestScore)
          .slice(0, 5) // Only top 5 topics
          .map((item, index) => {
            const todayRank = index + 1;
            const yesterdayRank = yesterdayRankings[item.topic];

            let isTrendingUp = null;
            if (yesterdayRank !== undefined) {
              if (todayRank < yesterdayRank) {
                isTrendingUp = true;
              } else if (todayRank > yesterdayRank) {
                isTrendingUp = false;
              } else {
                isTrendingUp = null;
              }
            } else {
              isTrendingUp = true;
            }

            return {
              ...item,
              rank: todayRank,
              isTrendingUp,
            };
          });

        return tableData;
      };

      // Process chart data
      const processChartData = (dailyData: any, dates: string[]) => {
        const topics: any = {};

        // Get top 5 topics from today
        const top5Topics = Object.entries(todayData)
          .filter(([_, score]) => typeof score === "number" && score > 0)
          .sort(([, a], [, b]) => Number(b) - Number(a))
          .slice(0, 5)
          .map(([topic, _]) => topic);

        // Build chart data for top 5 topics only
        top5Topics.forEach((topic: string) => {
          topics[topic] = {};
          dates.forEach((date: string) => {
            topics[topic][date] =
              dailyData[date] && dailyData[date][topic]
                ? dailyData[date][topic]
                : 0;
          });
        });

        return {
          topics,
          dateRanges: dates,
        };
      };

      // Process data
      const tableData = processTableData(todayData, yesterdayData);
      const chartData = processChartData(dailyData, availableDates);
      const allTopTopics = tableData.map((item) => item.topic); // Get all top 5 topics

      // Create React components
      const tableRoot = ReactDOM.createRoot(tableElement);
      const chartRoot = ReactDOM.createRoot(chartElement);

      tableRoot.render(
        React.createElement(TopicTable, {
          data: tableData,
          defaultSelectedTopic: null, // Don't pre-select any single topic in the table
        }),
      );

      chartRoot.render(
        React.createElement(TopicTrendChart, {
          data: chartData,
          defaultTopic: null, // Pass null as defaultTopic since we want all 5
          defaultTopics: allTopTopics, // Pass all 5 topics to be selected by default
        }),
      );
    } catch (error) {
      console.error("Error creating temporal trends:", error);
    }
  }

  // Main initialization function
  async function initializeRecap() {
    // Initialize animation controller first
    animationController = new ScrollAnimationController();
    
    // Register sections for animation
    const sectionIds = ['hero-section', 'temporal-section', 'network-section', 'insights-section'];
    animationController.registerSections(sectionIds);
    
    // Register the top entity span
    animationController.registerTopEntitySpan('top-entity');

    // Load actual top entity from today's data
    async function loadTopEntity(): Promise<string> {
      try {
        const today = new Date();
        const day = today.getDate().toString().padStart(2, "0");
        const month = (today.getMonth() + 1).toString().padStart(2, "0");
        const year = today.getFullYear();
        const formattedDate = `${day}.${month}.${year}`;

        const response = await fetch(`/data/${formattedDate}/topics.json`);
        if (!response.ok) {
          console.warn(`Could not load today's data (${formattedDate}), falling back to Donald Trump`);
          return "Donald Trump";
        }

        const data = await response.json();
        
        // Find the entity with the highest score
        const topEntry = Object.entries(data)
          .filter(([_, score]) => typeof score === "number" && score > 0)
          .sort(([, a], [, b]) => Number(b) - Number(a))[0];

        if (topEntry) {
          return topEntry[0];
        } else {
          console.warn("No valid entities found in today's data, falling back to Donald Trump");
          return "Donald Trump";
        }
      } catch (error) {
        console.error("Error loading top entity:", error);
        return "Donald Trump";
      }
    }

    const topEntity = await loadTopEntity();

    // Update the main top entity display
    animationController.updateTopEntity(topEntity);
    
    // Update all other entity references
    updateEntityReferences(topEntity);

    // Initialize all visualizations with coordinated timing
    // Start world map first since it's needed for hero section animation
    createCustomWorldMap(topEntity);
    
    // Then load other visualizations with delays
    setTimeout(() => createFilteredNetwork(topEntity), 800);
    setTimeout(() => createTemporalTrends(topEntity), 1200);
  }

  // Start the initialization when the page loads
  document.addEventListener("DOMContentLoaded", initializeRecap);
  
  // Cleanup when page unloads
  window.addEventListener("beforeunload", () => {
    if (animationController) {
      animationController.destroy();
    }
    window.removeEventListener('wheel', handleWheelScroll);
  });

  // Smooth scrolling logic
  let isScrolling = false;
  let scrollTimeout: number | undefined;
  const scrollCooldown = 800; // ms, adjust for desired sensitivity and animation time
  let currentSectionIndex = 0;
  const sections = ['hero-section', 'temporal-section', 'network-section', 'insights-section'];

  function scrollToSection(index: number) {
    if (index >= 0 && index < sections.length) {
      const sectionId = sections[index];
      const sectionElement = document.getElementById(sectionId);
      if (sectionElement) {
        isScrolling = true;
        sectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        currentSectionIndex = index;
        // Set a timeout to reset isScrolling after animation likely finishes
        // This assumes 'smooth' scroll takes roughly this long or less
        setTimeout(() => {
          isScrolling = false;
        }, scrollCooldown); // Match cooldown to prevent re-triggering during animation
      }
    }
  }

  function handleWheelScroll(event: WheelEvent) {
    if (isScrolling) {
      event.preventDefault(); // Prevent default scroll if an animation is in progress
      return;
    }

    // Clear any existing timeout to reset scroll intent if user scrolls again quickly
    clearTimeout(scrollTimeout);

    scrollTimeout = window.setTimeout(() => {
      if (event.deltaY > 0) {
        // Scrolling down
        if (currentSectionIndex < sections.length - 1) {
          scrollToSection(currentSectionIndex + 1);
        }
      } else if (event.deltaY < 0) {
        // Scrolling up
        if (currentSectionIndex > 0) {
          scrollToSection(currentSectionIndex - 1);
        }
      }
    }, 50); // Short debounce to capture scroll intent
    
    // Prevent default page scroll to allow custom handling only after debounce
    event.preventDefault(); 
  }

  // Add event listener after DOM is ready
  document.addEventListener("DOMContentLoaded", () => {
    // Initialize currentSectionIndex based on initial scroll position or default to 0
    const initialScrollY = window.scrollY;
    for(let i=0; i < sections.length; i++){
      const sectionElement = document.getElementById(sections[i]);
      if(sectionElement && sectionElement.offsetTop >= initialScrollY){
        currentSectionIndex = i;
        break;
      }
    }
    // Make sure the first section is visible on load, if no other section is in view.
    // This also helps if the page loads scrolled down slightly.
    if (window.scrollY < document.getElementById(sections[0])!.offsetHeight * 0.5 ) {
       scrollToSection(0);
    }

    window.addEventListener('wheel', handleWheelScroll, { passive: false });
  });
</script>

<style is:global>
  html {
    box-sizing: border-box;
    height: 100%;
    overflow-y: hidden; /* Body will handle scrolling */
  }

  *, *::before, *::after {
    box-sizing: inherit;
  }

  body {
    height: 100%;
    overflow-y: scroll; /* Make body the scroller */
    margin: 0; /* Reset default body margin */
  }
</style>

<style>
  /* Ensure visualizations fit properly */
  #world-map-recap,
  #network-recap,
  #temporal-trends-recap,
  #temporal-table-recap,
  #temporal-chart-recap {
    overflow: hidden;
  }

  /* Entity reference styling */
  .top-entity-ref {
    font-weight: 700;
    transition: all 0.3s ease;
  }

  /* Section layout improvements */
  #hero-section,
  #temporal-section,
  #network-section,
  #insights-section {
    /* scroll-snap-align: start; */ /* Removed */
    scroll-margin-top: 2rem; /* This can be kept if sections don't align perfectly to top */
  }

  /* Loading animation for the top entity */
  #top-entity {
    transition: all 0.5s ease;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    #top-entity {
      font-size: 3rem;
    }

    .container {
      padding-left: 1rem;
      padding-right: 1rem;
    }

    /* Stack temporal trends vertically on mobile */
    .grid.lg\\:grid-cols-7 {
      grid-template-columns: 1fr;
    }

    /* Adjust section heights for mobile */
    #hero-section,
    #temporal-section,
    #network-section,
    #insights-section {
      min-height: 100vh;
      padding: 2rem 0;
    }
  }

  /* Custom animations */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .fade-in {
    animation: fadeIn 0.6s ease-out;
  }

  /* Improved dark theme support */
  .dark .top-entity-ref {
    color: inherit;
  }

  /* Better visualization container styling */
  #world-map-recap,
  #network-recap {
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
  }

  .dark #world-map-recap,
  .dark #network-recap {
    background: rgba(0, 0, 0, 0.2);
  }
</style> 