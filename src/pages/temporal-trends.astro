---
import Layout from '@/layouts/Layout.astro';
import topicsData from '../../public/data/temporal_trends/topics.json';
import TopicTable from '@/components/TopicTable';
import TopicTrendChart from '@/components/TopicTrendChart';

// Add type definitions at the top of the script section
type TopicData = {
    [topic: string]: {
        [dateRange: string]: number;
    };
};

type TableRowData = {
    rank: number;
    topic: string;
    latestScore: number;
    isTrendingUp: boolean | null; // For rank trend (arrows)
    isPresenceTrendingUp: boolean | null; // For percentage change colors
    percentageChange: number | null;
};

// Function to parse date range string "DD-DD.MM" into a comparable format (e.g., Date object or YYYYMMDD)
// Assuming year is current year for simplicity, might need adjustment for year changes
const parseDateRange = (range: string): Date => {
    const currentYear = new Date().getFullYear();
    const [days, month] = range.split('.');
    const startDate = parseInt(days.split('-')[1], 10);
    return new Date(currentYear, parseInt(month, 10) - 1, startDate);
};

// Assert the type of imported JSON data
const typedTopicsData = topicsData as TopicData;

// Get all unique date ranges and sort them
const allDateRanges = [...new Set(Object.values(typedTopicsData).flatMap(topic => Object.keys(topic)))]
    .sort((a, b) => parseDateRange(a).getTime() - parseDateRange(b).getTime());

const latestDateRange = allDateRanges[allDateRanges.length - 1];
const previousDateRange = allDateRanges[allDateRanges.length - 2];

// Process data for the table
// First, create separate arrays for current and previous week data to calculate rankings
const currentWeekData = Object.entries(typedTopicsData)
    .map(([topic, dates]) => ({
        topic,
        score: dates[latestDateRange] ?? 0
    }))
    .filter(item => item.score > 0) // Only include topics with presence > 0
    .sort((a, b) => b.score - a.score) // Sort by score descending
    .map((item, index) => ({ ...item, rank: index + 1 })); // Add current rank

const previousWeekData = Object.entries(typedTopicsData)
    .map(([topic, dates]) => ({
        topic,
        score: dates[previousDateRange] ?? 0
    }))
    .filter(item => item.score > 0) // Only include topics with presence > 0
    .sort((a, b) => b.score - a.score) // Sort by score descending
    .map((item, index) => ({ ...item, rank: index + 1 })); // Add previous rank

// Create lookup maps for easy access
const currentWeekMap = new Map(currentWeekData.map(item => [item.topic, item]));
const previousWeekMap = new Map(previousWeekData.map(item => [item.topic, item]));

const tableData: TableRowData[] = Object.entries(typedTopicsData)
    .map(([topic, dates]) => {
        const currentLatestScore = dates[latestDateRange] ?? 0;
        const originalPreviousScoreValue = dates[previousDateRange];
        
        let isTrendingUp: boolean | null = null;
        let isPresenceTrendingUp: boolean | null = null;
        let percentageChange: number | null = null;

        // Calculate percentage change and presence trending
        if (originalPreviousScoreValue === undefined || originalPreviousScoreValue === null) {
            percentageChange = currentLatestScore;
            if (currentLatestScore > 0) {
                isPresenceTrendingUp = true;
            } else if (currentLatestScore < 0) {
                isPresenceTrendingUp = false;
            } else {
                isPresenceTrendingUp = null;
            }
        } else {
            const currentPreviousScore = originalPreviousScoreValue;
            if (currentLatestScore === currentPreviousScore) {
                percentageChange = 0;
                isPresenceTrendingUp = null;
            } else {
                // Determine presence trending based on score comparison
                isPresenceTrendingUp = currentLatestScore > currentPreviousScore;
                if (currentPreviousScore === 0) {
                    percentageChange = Infinity;
                } else {
                    percentageChange = parseFloat((currentLatestScore - currentPreviousScore).toFixed(1));
                }
            }
        }

        // Calculate rank-based trending (new logic for isTrendingUp)
        const currentWeekItem = currentWeekMap.get(topic);
        const previousWeekItem = previousWeekMap.get(topic);

        if (currentWeekItem && previousWeekItem) {
            // Topic exists in both weeks - compare ranks (lower rank number = better position)
            if (currentWeekItem.rank < previousWeekItem.rank) {
                isTrendingUp = true; // Improved rank (moved up)
            } else if (currentWeekItem.rank > previousWeekItem.rank) {
                isTrendingUp = false; // Worse rank (moved down)
            } else {
                isTrendingUp = null; // Same rank
            }
        } else if (currentWeekItem && !previousWeekItem) {
            // Topic is new this week (wasn't ranked last week)
            isTrendingUp = true;
        } else if (!currentWeekItem && previousWeekItem) {
            // Topic dropped out of rankings this week
            isTrendingUp = false;
        } else {
            // Topic not ranked in either week (shouldn't happen due to filtering)
            isTrendingUp = null;
        }

        return {
            topic,
            latestScore: currentLatestScore,
            isTrendingUp,
            isPresenceTrendingUp,
            percentageChange,
        };
    })
    .filter(item => item.latestScore > 0) // Only include topics with current presence > 0
    .sort((a, b) => b.latestScore - a.latestScore) // Sort by latest score descending for ranking
    .map((item, index) => ({ ...item, rank: index + 1 })); // Add final rank

// Determine the top topic for default selection
const topTopicName = tableData.length > 0 ? tableData[0].topic : null;

// Prepare data structure for the chart component
// Pass all data, chart component can filter/process as needed
const chartDataInput = {
    topics: typedTopicsData, // Use the typed data
    dateRanges: allDateRanges,
};

---

<Layout title="Temporal Trends">
    <main class="container mx-auto py-3">
        <h1 class="text-3xl font-bold mb-6 text-center">Topic Temporal Trends</h1>
        <div class="grid grid-cols-1 md:grid-cols-5 gap-8 h-[calc(100vh-200px)]">
            <div class="border rounded-lg p-4 overflow-y-auto md:col-span-2">
                <h2 class="text-xl font-semibold mb-4">Topic Rankings for week: {latestDateRange}</h2>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                    <p><span class="font-bold">Click on a row</span> to see the trend in the chart !</p>
                </div> 
                <TopicTable client:only="react" data={tableData} defaultSelectedTopic={topTopicName} />
            </div>
            <div class="border rounded-lg p-4 flex flex-col md:col-span-3">
                 <h2 class="text-xl font-semibold mb-4">Trend Evolution Comparison</h2>
                <div class="flex-grow min-h-[400px]">
                     <TopicTrendChart client:only="react" data={chartDataInput} defaultTopic={topTopicName} />
                </div>
            </div>
        </div>
    </main>
</Layout>
